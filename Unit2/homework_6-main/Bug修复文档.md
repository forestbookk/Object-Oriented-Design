# Bug修复文档

## Bug成因

在Reset过程中，将RequestTable中未完成的请求倒回请求池时，采用了**在RequestTable中逐一放回**的方式。根据我的函数设计，每次放回一个请求，都会notifyAll。这就导致调度器线程被唤醒的可能性大大提高，进入分配请求阶段，使得调度器线程锁住了调度器实例，接下来为了分配请求，它需要获得RequestTable的监视器，而这不可能完成，因为电梯线程早已抢先获得了该监视器，而此时电梯线程又在等待着获取调度器实例的监视器。从而构成了Scheduler线程和Elevator线程之间的死锁。

## Bug解决方案

我重新梳理了将请求倒回调度器中的请求池的思路（Elevator类的reset()方法），决定将**逐一倒回**的方式修改为**统一倒入**的方式，即，在Scheduler类中增加方法returnPool()，一次性将整个请求数组倒入请求池，同时不在此处设置notifyAll()，而是将这个任务交给我原本的设计——reset()方法的最后一步，还原reset属性。

且将调用调度器的“倒入”方法的位置统一设置在电梯的reset()方法，**避免出现同时获取RequestTable和Scheduler的锁**的情况。

## 总结

这是一个死锁问题，且成因十分明确单一。我从根本出发，进行了同质Bug修复。感谢助教老师的耐心阅读！您辛苦了！