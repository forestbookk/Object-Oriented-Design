## 第三次作业指导书

### 第零部分：提交要求 && Junit要求

请保证提交项目的顶层目录存在两个文件夹：`src`和`test`（命名需严格与此保持一致），请将作业的**功能代码**存放于`src`文件夹下，同时将相关**junit测试类代码**文件存放于`test`文件夹下，以保证评测的正常进行（评测时**只会**针对`src`目录下的文件进行程序**功能**的评测以及代码风格检测，也就是说，`test`目录下的junit测试代码风格不会被检测）。参考目录结构如下：

```plaintext
|-src
  |- Bottle.java
  |- Equipment.java
  |- ...
|-test
  |- BottleTest.java
  |- EquipmentTest.java
  |- ...
```

本次作业，要求Junit测试覆盖率**保证**`method >= 90％`，`line >= 60%`。（`idea`显示的覆盖率和`评测`测到的覆盖率可能略有差别，请同学们以评测为准）

### 第一部分：训练目标

* 学习并掌握“管理对象”-**容器**，熟悉 ArrayList 、HashMap 、HashSet 的使用
* 掌握对象的层次结构，通过编写更多的类进行类的层次结构的理解

### 第二部分：预备知识

#### Java 中常用的容器 `HashSet`

在上次作业同学们掌握了 HashMap 和 ArrayList 的基本用法之后，我们将介绍一个新的“容器”——`HashSet`

HashSet 是基于 HashMap 来实现的，是一个**不允许有重复元素**的集合，同时也允许有 null 值的出现。同 HashMap 一样，HashSet 也是无序的即不会记录插入的顺序，且 HashSet 中的元素也是对象，常见的基本类型所对应的包装类同 HashMap 相同，此处不做过多赘述。

```java
/* HashSet 类位于 java.util 包中，使用前需要引入它，语法格式如下：*/
import java.util.HashSet; // 引入 HashSet 类

public class HashSetSample {
    public void sample () {

       /* 1. 创建HashSet */
        /* HashMap<引用类型> <setName> = new HashSet<> */ 
        HashSet<Bottle> bottles = new HashSet<>(); 

        Bottle bottle1 = new Bottle(/*parameters*/);
        Bottle bottle2 = new Bottle(/*parameters*/);

        /* 2. 向HashSet内加入一个元素 */
        /* 集合名<setName>.add(对象) */
        bottles.add(bottle1);
        bottles.add(bottle2);
        bottles.add(bottle1); // 重复添加的元素不会被加入HahsSet中

        /* 3. 检查HashSet中是否存在指定的元素 */
        /* setName.contains(obj) */
        if (bottles.contains(bottle1)) { // true
            System.out.println("We have such a bottle!");
        }

        /* 4. HashSet大小, 即元素个数 */
        /* setName.size() */
        int size = bottles.size();

        /* 5. 遍历HashSet中的所有元素 */
        for (Bottle obj : bottles) {
            System.out.println("bottle's function is " + obj.getName());
        }
        
        /* 6. 删除HashSet中的指定元素
        /* setName.remove(obj) */
        bottles.remove(bottle2);       
    }
} 
```

## 第三部分：题目描述

### 背景

本次作业基于第二次的内容开发，同学们应当在实现第二次题目所要求的内容的前提下基于第二次的代码完成本次作业。

好的，经过上次作业的准备，我们的冒险者可以拥有一些装备和一些药水瓶，但是想要外出冒险，不可能带着所有的装备和所有的药水瓶瓶罐。因此在本次作业，我们新增了一个叫 **背包** 的概念。

同时为了量化冒险者的状态，我们为冒险者引入了两个属性：体力（HitPoint），等级（level）

体力代表冒险者当前的体力值，保证在程序正确运行时，冒险者体力时刻大于 0 。

等级，决定了他的背包的容量（后面会详细规定）

同时，关于等级，我们需要引入食物类（Food），通过使用食物可以提升冒险者的等级

在本次作业中，你需要实现的任务是：

- 在第一次作业的基础上完成冒险者新增加属性的管理
- 实现冒险者的背包功能，并依据要求约束实现背包内物品数目的控制


### 背包限制

在上一次的作业里，我们定义了添加的概念（add），这个仅仅是让这名冒险者拥有了这个物品，但是他并没有携带这个物品。我们认为，当且仅当**这个物品属于该冒险者且在该名冒险者的背包中**，才算他携带了这个物品。

下面对每类物品给出携带与使用的规定。

#### 装备

##### 限制

**冒险者只能携带一件同名装备**。

若冒险者已经携带了名字为 `sword` 的装备（该装备 `id` 为 $1$），下一次再尝试携带另一个名字为 `sword ` 的不同装备（该装备`id`为 $2$）时，原本 `id` 为 $1$ 的 `sword` 会被顶替。注意被顶替的装备依然属于此冒险者。

#### 药水瓶

当冒险者携带药水瓶 A 时，他才能使用该药水瓶 A，否则为使用失败。

冒险者使用某药水瓶时，若药水瓶不为空，则冒险者的体力增加 $x$（$x$ 为该药水瓶的容积），药水瓶变空。

若药水瓶为空，冒险者的体力增加为 0，同样视作使用成功。同时，为了给继续携带药水瓶腾出空间，在使用后冒险者将丢弃该空药水瓶，即该药水瓶将不再被该冒险者拥有。对于这个丢弃行为我们不需要进行输出。

##### 限制

冒险者只能携带 `max_bottles` 个同名的药水瓶，其中max_bottles的值满足 $$ {max\\_bottles} = (\lfloor \dfrac{\text{level}}5\rfloor+1)$$

例如，若冒险者等级为 19, 则 `max_bottles` 的值是 $4$。假如在这时，该冒险者携带了四个同名药水瓶 `water`，之后再尝试携带同名的药水瓶后时，他的状态不会有任何改变，也不需要输出任何内容，他也不会携带新的同名药水瓶。

#### 食物

当冒险者携带食物 A 的时候，他才能使用该食物 A，否则为使用失败。

当冒险者使用食物时，他将消耗掉该食物（从此该食物**不再属于**该冒险者），冒险者的等级提升 $x$（$x$ 为食物的能量）。

比如冒险者当前等级为 1，拥有食物 A，A 的能量为 2。冒险者在携带后使用食物 A，则冒险者不再拥有食物 A，同时冒险者的等级变为 3。

##### 限制

背包对食物的数量没有任何限制。



特别的，我们规定，假设冒险者 A 尝试携带的物品 B ，本身已经在冒险者背包里了，那么该条指令不会造成任何影响（不需要任何输出，同时物品 B 依旧在冒险者的背包里 ）

### 操作要求

在本次作业中，初始时，你没有需要管理的冒险者，我们通过若干条操作指令来修改当前的状态：

（**第2-6条同第一次作业**）

1. 加入一个需要管理的冒险者（新加入的冒险者不携带任何药水瓶、食物和装备，并且等级为 $1$，初始体力为 $500$）
2. 给某个冒险者增加一个药水瓶
3. 删除某个冒险者的某个药水瓶
4. 给某个冒险者增加一个装备
5. 删除某个冒险者的某个装备
6. 给某个冒险者的某个装备提升一个星级
7. 给冒险者增加一个食物
8. 删除冒险者的一个食物
9. 冒险者尝试携带他拥有的某件装备
10. 冒险者尝试携带他拥有的某个药水瓶
11. 冒险者尝试携带他拥有的某个食物
12. 冒险者使用某个药水瓶
13. 冒险者使用某个食物

**值得注意的是，在12和13中，我们采用 name 来确定所使用的物品。假设当前冒险者携带了多个同名物品，则使用 id最小的那个。**


同时，指令使用名字为name的物品时，如果冒险者携带了名字为该 name 的物品，则视为使用成功，（使用空瓶也算使用成功），假设冒险者没有携带名字为该 name 的物品，则视为使用失败，不产生任何其他影响。。两种情况需按照下面的输入输出格式进行输出

### 输入输出格式

第一行一个整数 $n$，表示操作的个数。

接下来的 $n$ 行，每行一个形如 `{type} {attribute}` 的操作，`{type}` 和 `{attribute}` 间、若干个 `{attribute}` 间使用**若干**个空格分割，操作输入形式及其含义如下

| type | attribute                             | 意义                                                         | 输出（每条对应占一行）                                       |
| :--- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | `{adv_id} {name}`                     | 加入一个 ID 为 `{adv_id}`、名字为 `{name}` 的冒险者          | 无                                                           |
| 2    | `{adv_id} {bot_id} {name} {capacity}` | 给 ID 为 `{adv_id}` 的冒险者增加一个药水瓶，药水瓶的 ID、名字、容量分别为 `{bot_id}`、`{name}`、`{capacity}`，**且默认为已装满** | 无                                                           |
| 3    | `{adv_id} {bot_id}`                   | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{bot_id}` 的药水瓶删除 | `{一个整数} {一个字符串}`，整数为删除后冒险者药水瓶数目，字符串为删除的药水瓶的name |
| 4    | `{adv_id} {equ_id} {name} {star}`     | 给 ID 为 `{adv_id}` 的冒险者增加一个装备，装备的 ID、名字、星级分别为 `{equ_id}`、`{name}`、`{star}` | 无                                                           |
| 5    | `{adv_id} {equ_id}`                   | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{equ_id}` 的装备删除   | `{一个整数} {一个字符串}`，整数为删除后冒险者装备数目，字符串为删除的装备的name |
| 6    | `{adv_id} {equ_id}`                   | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{equ_id}` 的装备提升一个星级 | `{一个字符串} {一个整数}`，字符串为装备的name，整数为装备升星后的星级 |
| 7    | `{adv_id} {food_id} {name} {energy}`  | 给 ID 为 `{adv_id}` 的冒险者增加一个食物，食物的 ID、名字、能量分别为 `{equ_id}`、`{name}`、`{energy}` | 无                                                           |
| 8    | `{adv_id} {food_id}`                  | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{food_id}` 的食物删除  | `{一个整数} {一个字符串}`，整数为删除后冒险者食物数目，字符串为删除的食物的 name |
| 9    | `{adv_id} {equ_id}`                   | ID 为 `{adv_id}` 的冒险者尝试携带ID为 `{equ_id}` 的装备      | 无                                                           |
| 10   | `{adv_id} {bot_id}`                   | ID 为 `{adv_id}` 的冒险者尝试携带ID为 `{bot_id}` 的瓶子      | 无                                                           |
| 11   | `{adv_id} {food_id}`                  | ID 为 `{adv_id}` 的冒险者尝试携带ID为 `{food_id}` 的食物     | 无                                                           |
| 12   | `{adv_id} {name}`                     | ID 为 `{adv_id}` 的冒险者尝试使用他拥有的名字为`{name}`的药水瓶 | 成功：`{一个整数A} {一个整数B}`，整数A为被使用药水瓶的id，整数B为该冒险者使用该药水瓶后的体力值 <br/> 失败： `fail to use {name}`，name为本条指令输入中的name) |
| 13   | `{adv_id} {name}`                     | ID 为 `{adv_id}` 的冒险者尝试使用他拥有的名字为`{name}`的食物 | 成功：`{一个整数A} {一个整数B}`，整数A为被使用食物的 id，整数B为该冒险者使用该食物后的等级 <br/>失败：  `fail to eat {name}`，name 为本条指令输入中的 name |

### 样例

#### 输入

```
16
1 123456 advName
2 123456 123 bottleName 40
10 123456 123
2 123456 321 bottleName 20
10 123456 321
12 123456 bottleName
12 123456 bottleName
12 123456 bottleName
7 123456 111 foodName 10
7 123456 888 candy 20
8 123456 888
13 123456 foodName
11 123456 111
13 123456 foodName
7 123456 222 foodName 30
8 123456 222
```

#### 输出

```
123 540
123 540
fail to use bottleName
1 candy
fail to eat foodName
111 11
0 foodName
```

### 数据限制

#### 变量约束

| 变量       | 类型   | 说明                                   |
| ---------- | ------ | -------------------------------------- |
| `id `      | 整数   | 取值范围：0 - 2147483647               |
| `name`     | 字符串 | 保证不会出现空白字符，长度区间: (0,40) |
| `capacity` | 整数   | 取值范围：0 - 2147483647               |
| `star`     | 整数   | 取值范围：0 - 2147483647               |
| `energy`   | 整数   | 取值范围： 0-2147483647                |
| `level`    | 整数   | 取值范围：1 - 2147483647               |
| `HitPoint` | 整数   | 取值范围：0 - 2147483647               |

注意，变量约束指的是，在程序运行时，输入和对应属性值均保证在表格中给出的范围内。

#### 操作约束

1. **保证所有的冒险者、药水瓶、装备、食物id均不相同**
2. 保证删除了的药水瓶/装备/食物的 id 不会再次出现
3. 操作 2-6 保证所有冒险者均已存在
4. 操作 3/5/6/8 保证该冒险者拥有操作中提到 id 的药水瓶/装备/食物
5. 保证增加的装备，食物和药水瓶原本不存在
6. 操作数满足$1\le n\le2000$
7. 操作 9-11保证该冒险者拥有操作中提到 id 的药水瓶/装备/食物
8. 操作 12-13 **不**保证提到的物品已经被携带

### 提示

考虑到正课尚未讲解有关输入解析的内容，我们在此提供一份输入解析代码，同学们可以将其复制到自己代码中的适当位置直接使用，当然，同学们也可以自行设计代码来进行输入解析。

```java
ArrayList<ArrayList<String>> inputInfo = new ArrayList<>(); // 解析后的输入将会存进该容器中, 类似于c语言的二维数组
Scanner scanner = new Scanner(System.in);
int n = Integer.parseInt(scanner.nextLine().trim()); // 读取行数
for (int i = 0; i < n; ++i) {
    String nextLine = scanner.nextLine(); // 读取本行指令
    String[] strings = nextLine.trim().split(" +"); // 按空格对行进行分割
    inputInfo.add(new ArrayList<>(Arrays.asList(strings))); // 将指令分割后的各个部分存进容器中
}
```

经过这段代码，输入的信息会被存入 `inputInfo` 这个"二维数组"中，遍历该容器即可取出各行指令及其各个部分。
